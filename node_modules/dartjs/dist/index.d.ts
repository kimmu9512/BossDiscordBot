/// <reference types="node" />
import * as discord_js from 'discord.js';
import { VoiceChannel, StageChannel, Client, UserResolvable, Collection, GuildVoiceChannelResolvable } from 'discord.js';
import * as _discordjs_voice from '@discordjs/voice';
import { StreamType, JoinConfig, CreateAudioPlayerOptions, AudioResource, VoiceConnection as VoiceConnection$1, NoSubscriberBehavior, VoiceConnectionStatus } from '@discordjs/voice';
import { TypedEmitter } from 'tiny-typed-emitter';
import { Readable, TransformOptions, Transform } from 'stream';

declare function injectSmoothVolume(): void;

declare type VoiceChannels = VoiceChannel | StageChannel;
interface VoiceEvents {
    debug: (message: string) => void;
    error: (error: Error) => void;
    disconnect: () => void;
}
interface VoiceReceiverEvents {
    debug: (message: string) => void;
}
interface DispatcherEvents<T = unknown> {
    start: (metadata?: {
        nonce?: string;
        data?: T;
    }) => void;
    finish: (metadata?: {
        nonce?: string;
        data?: T;
    }) => void;
    error: (error: Error) => void;
    debug: (message: string) => void;
    volumeChange: (oldVolume: number, newVolume: number) => void;
}
interface VoiceConnectionData {
    channel: VoiceChannels;
    manager: DartVoiceManager;
}
interface PlayOptions<T = unknown> {
    /** The stream type */
    type?: `${StreamType}` | StreamType | "converted" | "unknown";
    /** Enable/disable on-the-fly volume controls */
    inlineVolume?: boolean;
    /** Silence padding frames */
    silencePaddingFrames?: number;
    /** Initial volume */
    initialVolume?: number;
    /** Volume smoothness */
    volumeSmoothness?: number;
    /** Track metadata */
    metadata?: T;
    /** Ignore previous track event on running `<Dispatcher>.play()` */
    ignorePrevious?: boolean;
}
interface ReceiveStreamOptions {
    mode?: "opus" | "pcm";
    end?: "silence" | "manual";
}
declare type VoiceJoinConfig = Omit<JoinConfig, "channelId" | "guildId">;

interface ArMetadata<T = unknown> {
    nonce: string;
    data: T;
}
declare class StreamDispatcher<T = unknown> extends TypedEmitter<DispatcherEvents<T>> {
    readonly connection: VoiceConnection;
    audioPlayerOptions: CreateAudioPlayerOptions;
    audioPlayer: _discordjs_voice.AudioPlayer;
    audioResource: AudioResource<ArMetadata<T>>;
    private _readyLock;
    private _ignoreList;
    private _nextTickCallbacks;
    private _immediateCallbacks;
    constructor(connection: VoiceConnection, audioPlayerOptions?: CreateAudioPlayerOptions);
    cleanUp(): void;
    private attachEvents;
    /**
     * Stop the player
     * @param [force=false] If the playback should be forcefully stopped
     */
    end(force?: boolean): void;
    /**
     * Stop the player
     * @param [force=false] If the playback should be forcefully stopped
     */
    stop(force?: boolean): void;
    /**
     * Play stream over voice connection
     * @param stream The readable stream or stream source url to play
     * @param options Play options
     */
    playStream(stream: Readable | string, options?: PlayOptions<T>): void;
    /**
     * Set volume
     * @param amount The volume amount to set
     */
    setVolume(amount: number): boolean;
    /**
     * Set volume in percentage
     * @param amount The volume amount to set
     */
    setVolumePercentage(percentage: number): boolean;
    /**
     * Set volume in logarithmic value
     * @param amount The volume to set
     */
    setVolumeLogarithmic(amount: number): boolean;
    /**
     * Set volume in decibels
     * @param amount The volume in decibels
     */
    setVolumeDecibels(amount: number): boolean;
    /**
     * Get current volume amount
     */
    get volume(): number;
    /**
     * Get current volume in percentage
     */
    get volumePercentage(): number;
    /**
     * Get current volume as decibels
     */
    get volumeDecibels(): number;
    /**
     * Get current volume as logarithmic value
     */
    get volumeLogarithmic(): number;
    /**
     * Check if the volume is editable
     */
    get volumeEditable(): boolean;
    /**
     * Volume smoothness availability
     */
    get volumeSmoothnessEditable(): boolean;
    /**
     * Set volume smoothness
     * @param smoothness
     */
    setVolumeSmoothness(smoothness: number): boolean;
    /**
     * Get volume smoothness
     */
    get volumeSmoothness(): number;
    /**
     * The actual streamed duration in ms of current audio resource
     */
    get streamTime(): number;
    /**
     * The total streamed duration in ms of the current audio resource, including paused states
     */
    get totalStreamTime(): number;
    /**
     * The paused state
     */
    get paused(): boolean;
    /**
     * Pause the player
     * @param silence Send silence frame during paused state
     */
    pause(silence?: boolean): void;
    /**
     * Resumes the player
     */
    resume(): void;
    /**
     * Callback provided here runs whenever next track is playable
     * @param cb The callback function
     */
    next(cb: () => unknown): void;
    /**
     * Callback provided here runs whenever next track is playable
     * @param cb The callback function
     */
    immediate(cb: () => unknown): void;
    private _immediateCall;
    private _nextTickCall;
}

declare class VoiceReceiver extends TypedEmitter<VoiceReceiverEvents> {
    readonly client: Client<true>;
    readonly connection: VoiceConnection;
    constructor(client: Client<true>, connection: VoiceConnection);
    cleanUp(): void;
    /**
     * Create receiver stream
     * @param user The target user to listen to
     * @param options Receiver options
     */
    createStream(user: UserResolvable, options?: ReceiveStreamOptions): Readable;
}

declare class VoiceConnection extends TypedEmitter<VoiceEvents> {
    voice: VoiceConnection$1;
    readonly options: VoiceConnectionData;
    readonly client: discord_js.Client<boolean>;
    readonly channel: VoiceChannels;
    dispatcher: StreamDispatcher;
    readonly voiceManager: DartVoiceManager;
    receiver: VoiceReceiver;
    constructor(voice: VoiceConnection$1, options: VoiceConnectionData);
    /**
     * The audio player
     */
    get audioPlayer(): _discordjs_voice.AudioPlayer;
    /**
     * Disconnect from this connection
     */
    disconnect(): void;
    /**
     * Destroy this connection
     */
    destroy(): void;
    /**
     * Create a voice connection
     * @param channel The voice channel
     * @param manager The voice manager
     * @param options Join config
     */
    static createConnection(channel: VoiceChannels, manager: DartVoiceManager, options?: VoiceJoinConfig): Promise<VoiceConnection>;
    /**
     * Join a voice channel
     * @param channel The voice channel
     * @param options The join config
     */
    static joinChannel(channel: VoiceChannels, options?: VoiceJoinConfig): Promise<VoiceConnection$1>;
    /**
     * Play readable stream or remote stream source in this connection
     * @param stream The stream source
     * @param options The play options
     */
    play<T = unknown>(stream: Readable | string, options?: PlayOptions<T> & {
        behaviours?: {
            noSubscriber?: NoSubscriberBehavior;
            maxMissedFrames?: number;
        };
    }): StreamDispatcher<T>;
    /**
     * The voice connection status
     */
    get status(): VoiceConnectionStatus;
    /**
     * The voice connection latency (udp)
     */
    get ping(): number;
}

declare class DartVoiceManager {
    readonly client: Client;
    connections: Collection<string, VoiceConnection>;
    constructor(client: Client);
    /**
     * Join a voice channel
     * @param channel The voice based channel
     * @param options Join config
     */
    join(channel: GuildVoiceChannelResolvable, options?: VoiceJoinConfig): Promise<VoiceConnection>;
    /**
     * Leave a voice channel
     * @param channel The voice channel
     */
    leave(channel: GuildVoiceChannelResolvable): void;
    /**
     * Update voice connection
     * @param connection The voice connection
     * @param channel The new voice channel
     */
    updateChannel(connection: VoiceConnection, channel: VoiceChannels): Promise<VoiceConnection>;
}

interface VolumeTransformerOptions extends TransformOptions {
    type?: "s16le" | "s16be" | "s32le" | "s32be";
    smoothness?: number;
    volume?: number;
}
declare class VolumeTransformer extends Transform {
    private _bits;
    private _smoothing;
    private _bytes;
    private _extremum;
    private _chunk;
    volume: number;
    private _targetVolume;
    type: "s16le" | "s32le" | "s16be" | "s32be";
    constructor(options?: VolumeTransformerOptions);
    _readInt(buffer: Buffer, index: number): number;
    _writeInt(buffer: Buffer, int: number, index: number): number;
    _applySmoothness(): void;
    _transform(chunk: Buffer, encoding: BufferEncoding, done: () => unknown): unknown;
    _destroy(err: Error, cb: (error: Error) => void): void;
    setVolume(volume: number): void;
    setVolumeDecibels(db: number): void;
    setVolumeLogarithmic(value: number): void;
    get volumeDecibels(): number;
    get volumeLogarithmic(): number;
    get smoothness(): number;
    setSmoothness(smoothness: number): void;
    smoothingEnabled(): boolean;
    get hasSmoothness(): boolean;
    static get hasSmoothing(): boolean;
}

declare function catchError<T>(promiseLike: () => Promise<T>): Promise<[Error, T]>;
declare function noop(): void;
declare function wait(duration: number): Promise<unknown>;
declare function randomId(): string;

export { DartVoiceManager, DispatcherEvents, PlayOptions, ReceiveStreamOptions, StreamDispatcher, VoiceChannels, VoiceConnection, VoiceConnectionData, VoiceEvents, VoiceJoinConfig, VoiceReceiver, VoiceReceiverEvents, VolumeTransformer, VolumeTransformerOptions, catchError, injectSmoothVolume, noop, randomId, wait };
