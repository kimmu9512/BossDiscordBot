"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartVoiceManager = void 0;
const discord_js_1 = require("discord.js");
const VoiceConnection_1 = __importDefault(require("./VoiceConnection"));
class DartVoiceManager {
    constructor(client) {
        this.client = client;
        this.connections = new discord_js_1.Collection();
    }
    /**
     * Join a voice channel
     * @param channel The voice based channel
     * @param options Join config
     */
    join(channel, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const vc = this.client.channels.resolve(channel !== null && channel !== void 0 ? channel : "");
            if (!vc || !vc.isVoice())
                throw new Error("Voice channel was not provided!");
            if (!["GUILD_STAGE_VOICE", "GUILD_VOICE"].includes(vc.type)) {
                throw new TypeError("Cannot join non-voice channel");
            }
            if (this.connections.has(vc.guildId)) {
                return yield this.updateChannel(this.connections.get(vc.guildId), vc);
            }
            else {
                const connection = yield VoiceConnection_1.default.createConnection(vc, this, options);
                this.connections.set(vc.guildId, connection);
                return connection;
            }
        });
    }
    /**
     * Leave a voice channel
     * @param channel The voice channel
     */
    leave(channel) {
        const vc = this.client.channels.resolve(channel !== null && channel !== void 0 ? channel : "");
        if (!vc || !vc.isVoice())
            throw new Error("Voice channel was not provided!");
        if (!["GUILD_STAGE_VOICE", "GUILD_VOICE"].includes(vc.type)) {
            throw new TypeError("Cannot leave non-voice channel");
        }
        if (!this.connections.has(vc.guildId))
            return;
        const connection = this.connections.get(vc.guildId);
        connection.disconnect();
        connection.destroy();
        this.connections.delete(vc.guildId);
    }
    /**
     * Update voice connection
     * @param connection The voice connection
     * @param channel The new voice channel
     */
    updateChannel(connection, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const vc = yield VoiceConnection_1.default.joinChannel(channel);
            connection.voice = vc;
            connection.options.channel = channel;
            this.connections.set(connection.channel.guildId, connection);
            return connection;
        });
    }
}
exports.default = DartVoiceManager;
exports.DartVoiceManager = DartVoiceManager;
