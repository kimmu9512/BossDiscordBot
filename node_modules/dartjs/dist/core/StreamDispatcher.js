"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDispatcher = void 0;
const voice_1 = require("@discordjs/voice");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const Util_1 = require("../Utils/Util");
class StreamDispatcher extends tiny_typed_emitter_1.TypedEmitter {
    constructor(connection, audioPlayerOptions = {}) {
        super();
        this.connection = connection;
        this.audioPlayerOptions = audioPlayerOptions;
        this.audioPlayer = (0, voice_1.createAudioPlayer)(this.audioPlayerOptions || {});
        this.audioResource = null;
        this._readyLock = false;
        this._ignoreList = new Set();
        this._nextTickCallbacks = new Array();
        this._immediateCallbacks = new Array();
        this.attachEvents();
        this.connection.voice.subscribe(this.audioPlayer);
    }
    cleanUp() {
        this.connection.voice.removeAllListeners("stateChange");
        this.connection.voice.removeAllListeners("debug");
        this.connection.voice.removeAllListeners("error");
        this.audioPlayer.removeAllListeners("stateChange");
        this.audioPlayer.removeAllListeners("error");
    }
    attachEvents() {
        if (!this.connection.voice.eventNames().includes("stateChange"))
            // @ts-expect-error Argument of type '"stateChange"' is not assignable to parameter of type 'VoiceConnectionStatus.Signalling'?
            this.connection.voice.on("stateChange", (_, newState) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (newState.status === voice_1.VoiceConnectionStatus.Disconnected) {
                    if (newState.reason === voice_1.VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {
                        try {
                            yield (0, voice_1.entersState)(this.connection.voice, voice_1.VoiceConnectionStatus.Connecting, 5000);
                        }
                        catch (_b) {
                            this.connection.voiceManager.connections.delete(this.connection.channel.guildId);
                            this.connection.emit("disconnect");
                            this.connection.voice.destroy();
                        }
                    }
                    else if (this.connection.voice.rejoinAttempts < 5) {
                        yield (0, Util_1.wait)((this.connection.voice.rejoinAttempts + 1) * 5000);
                        this.connection.voice.rejoin();
                    }
                    else {
                        this.connection.voiceManager.connections.delete(this.connection.channel.guildId);
                        this.connection.emit("disconnect");
                        this.connection.voice.destroy();
                    }
                }
                else if (newState.status === voice_1.VoiceConnectionStatus.Destroyed) {
                    (_a = this.audioPlayer) === null || _a === void 0 ? void 0 : _a.stop();
                }
                else if (!this._readyLock && (newState.status === voice_1.VoiceConnectionStatus.Connecting || newState.status === voice_1.VoiceConnectionStatus.Signalling)) {
                    this._readyLock = true;
                    try {
                        yield (0, voice_1.entersState)(this.connection.voice, voice_1.VoiceConnectionStatus.Ready, 20000);
                    }
                    catch (_c) {
                        if (this.connection.voice.state.status !== voice_1.VoiceConnectionStatus.Destroyed)
                            this.connection.voice.destroy();
                        this.connection.voiceManager.connections.delete(this.connection.channel.guildId);
                        this.connection.emit("disconnect");
                    }
                    finally {
                        this._readyLock = false;
                    }
                }
            }));
        if (!this.audioPlayer.eventNames().includes("stateChange"))
            // @ts-expect-error Argument of type '"stateChange"' is not assignable to parameter of type 'AudioPlayerStatus.Idle'?
            this.audioPlayer.on("stateChange", (oldState, newState) => {
                var _a, _b, _c, _d, _e, _f;
                if (newState.status === voice_1.AudioPlayerStatus.Idle && oldState.status !== voice_1.AudioPlayerStatus.Idle) {
                    this._immediateCall();
                    const nonce = (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.nonce;
                    if (typeof nonce === "string" && this._ignoreList.has(nonce))
                        return this._ignoreList.delete(nonce);
                    this.emit("finish", (_c = this.audioResource) === null || _c === void 0 ? void 0 : _c.metadata);
                }
                else if (newState.status === voice_1.AudioPlayerStatus.Playing && oldState.status === voice_1.AudioPlayerStatus.Buffering) {
                    this._nextTickCall();
                    const nonce = (_e = (_d = this.audioResource) === null || _d === void 0 ? void 0 : _d.metadata) === null || _e === void 0 ? void 0 : _e.nonce;
                    if (this._ignoreList.has(nonce))
                        return this._ignoreList.delete(nonce);
                    // emit the event
                    this.emit("start", (_f = this.audioResource) === null || _f === void 0 ? void 0 : _f.metadata);
                }
            });
        if (!this.connection.voice.eventNames().includes("debug"))
            this.connection.voice.on("debug", (m) => void this.connection.emit("debug", m));
        if (!this.connection.voice.eventNames().includes("error"))
            this.connection.voice.on("error", (error) => void this.connection.emit("error", error));
        if (!this.audioPlayer.eventNames().includes("debug"))
            this.audioPlayer.on("debug", (m) => void this.emit("debug", m));
        if (!this.audioPlayer.eventNames().includes("error"))
            this.audioPlayer.on("error", (error) => void this.emit("error", error));
    }
    /**
     * Stop the player
     * @param [force=false] If the playback should be forcefully stopped
     */
    end(force = false) {
        this.audioPlayer.stop(force);
    }
    /**
     * Stop the player
     * @param [force=false] If the playback should be forcefully stopped
     */
    stop(force = false) {
        this.end(force);
    }
    /**
     * Play stream over voice connection
     * @param stream The readable stream or stream source url to play
     * @param options Play options
     */
    playStream(stream, options) {
        var _a, _b, _c;
        const audioResource = (0, voice_1.createAudioResource)(stream, {
            inputType: 
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            {
                // discord.js v12 types
                converted: voice_1.StreamType.Raw,
                unknown: voice_1.StreamType.Arbitrary
            }[options === null || options === void 0 ? void 0 : options.type] ||
                (options === null || options === void 0 ? void 0 : options.type) ||
                voice_1.StreamType.Arbitrary,
            inlineVolume: (_a = options === null || options === void 0 ? void 0 : options.inlineVolume) !== null && _a !== void 0 ? _a : true,
            silencePaddingFrames: typeof (options === null || options === void 0 ? void 0 : options.silencePaddingFrames) !== "number" ? 5 : options === null || options === void 0 ? void 0 : options.silencePaddingFrames,
            metadata: Object.defineProperties({}, {
                nonce: {
                    value: (0, Util_1.randomId)(),
                    enumerable: true,
                    writable: false,
                    configurable: false
                },
                data: {
                    value: options === null || options === void 0 ? void 0 : options.metadata,
                    writable: true,
                    enumerable: true,
                    configurable: true
                }
            })
        });
        if (typeof (options === null || options === void 0 ? void 0 : options.initialVolume) === "number" && audioResource.volume) {
            Reflect.set(audioResource.volume, "volume", options.initialVolume);
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.volumeSmoothness) === "number" && audioResource.volume && audioResource.volume.hasSmoothness) {
            Reflect.set(audioResource.volume, "_smoothing", options.volumeSmoothness || 0);
        }
        if ((options === null || options === void 0 ? void 0 : options.ignorePrevious) && ((_c = (_b = this.audioResource) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.nonce))
            this._ignoreList.add(this.audioResource.metadata.nonce);
        this.end(true);
        this.audioResource = audioResource;
        this.audioPlayer.play(audioResource);
    }
    /**
     * Set volume
     * @param amount The volume amount to set
     */
    setVolume(amount) {
        var _a, _b, _c;
        const lastVolume = this.volume;
        if (lastVolume === amount || !((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume))
            return false;
        (_c = (_b = this.audioResource) === null || _b === void 0 ? void 0 : _b.volume) === null || _c === void 0 ? void 0 : _c.setVolume(amount);
        this.emit("volumeChange", lastVolume, this.volume);
        return true;
    }
    /**
     * Set volume in percentage
     * @param amount The volume amount to set
     */
    setVolumePercentage(percentage) {
        var _a, _b, _c;
        const lastVolume = this.volumePercentage;
        if (lastVolume === percentage || !((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume))
            return false;
        (_c = (_b = this.audioResource) === null || _b === void 0 ? void 0 : _b.volume) === null || _c === void 0 ? void 0 : _c.setVolume(percentage / 100);
        this.emit("volumeChange", lastVolume / 100, this.volume);
        return true;
    }
    /**
     * Set volume in logarithmic value
     * @param amount The volume to set
     */
    setVolumeLogarithmic(amount) {
        var _a, _b, _c;
        const lastVolume = this.volume;
        if (lastVolume === amount || !((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume))
            return false;
        (_c = (_b = this.audioResource) === null || _b === void 0 ? void 0 : _b.volume) === null || _c === void 0 ? void 0 : _c.setVolumeLogarithmic(amount);
        this.emit("volumeChange", lastVolume, this.volume);
        return true;
    }
    /**
     * Set volume in decibels
     * @param amount The volume in decibels
     */
    setVolumeDecibels(amount) {
        var _a, _b, _c;
        const lastVolume = this.volume;
        if (lastVolume === amount || !((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume))
            return false;
        (_c = (_b = this.audioResource) === null || _b === void 0 ? void 0 : _b.volume) === null || _c === void 0 ? void 0 : _c.setVolumeDecibels(amount);
        this.emit("volumeChange", lastVolume, this.volume);
        return true;
    }
    /**
     * Get current volume amount
     */
    get volume() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume) === null || _b === void 0 ? void 0 : _b.volume) !== null && _c !== void 0 ? _c : 1;
    }
    /**
     * Get current volume in percentage
     */
    get volumePercentage() {
        return this.volume * 100;
    }
    /**
     * Get current volume as decibels
     */
    get volumeDecibels() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume) === null || _b === void 0 ? void 0 : _b.volumeDecibels) !== null && _c !== void 0 ? _c : 1;
    }
    /**
     * Get current volume as logarithmic value
     */
    get volumeLogarithmic() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume) === null || _b === void 0 ? void 0 : _b.volumeLogarithmic) !== null && _c !== void 0 ? _c : 1;
    }
    /**
     * Check if the volume is editable
     */
    get volumeEditable() {
        var _a;
        return Boolean((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume);
    }
    /**
     * Volume smoothness availability
     */
    get volumeSmoothnessEditable() {
        var _a;
        return !!((_a = this.audioResource.volume) === null || _a === void 0 ? void 0 : _a.hasSmoothness);
    }
    /**
     * Set volume smoothness
     * @param smoothness
     */
    setVolumeSmoothness(smoothness) {
        if (!this.volumeSmoothnessEditable)
            return false;
        Reflect.set(this.audioResource.volume, "_smoothing", smoothness);
        return true;
    }
    /**
     * Get volume smoothness
     */
    get volumeSmoothness() {
        var _a;
        return ((_a = this.audioResource.volume) === null || _a === void 0 ? void 0 : _a.smoothness) || 0;
    }
    /**
     * The actual streamed duration in ms of current audio resource
     */
    get streamTime() {
        var _a, _b;
        return (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.playbackDuration) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * The total streamed duration in ms of the current audio resource, including paused states
     */
    get totalStreamTime() {
        var _a, _b;
        return ((_a = this.audioPlayer) === null || _a === void 0 ? void 0 : _a.state.status) === voice_1.AudioPlayerStatus.Playing ? (_b = this.audioPlayer) === null || _b === void 0 ? void 0 : _b.state.playbackDuration : 0;
    }
    /**
     * The paused state
     */
    get paused() {
        return this.audioPlayer.state.status === voice_1.AudioPlayerStatus.Paused || this.audioPlayer.state.status === voice_1.AudioPlayerStatus.AutoPaused;
    }
    /**
     * Pause the player
     * @param silence Send silence frame during paused state
     */
    pause(silence = false) {
        var _a;
        (_a = this.audioPlayer) === null || _a === void 0 ? void 0 : _a.pause(silence);
    }
    /**
     * Resumes the player
     */
    resume() {
        var _a;
        (_a = this.audioPlayer) === null || _a === void 0 ? void 0 : _a.unpause();
    }
    /**
     * Callback provided here runs whenever next track is playable
     * @param cb The callback function
     */
    next(cb) {
        if (!cb || typeof cb !== "function")
            throw new TypeError("Next tick callback must be a function");
        this._nextTickCallbacks.push(cb);
    }
    /**
     * Callback provided here runs whenever next track is playable
     * @param cb The callback function
     */
    immediate(cb) {
        if (!cb || typeof cb !== "function")
            throw new TypeError("Next tick callback must be a function");
        this._immediateCallbacks.push(cb);
    }
    _immediateCall() {
        if (!this._immediateCallbacks.length)
            return;
        this._immediateCallbacks.forEach((cb, idx) => {
            void this._immediateCallbacks.splice(idx, 1);
            cb();
        });
    }
    _nextTickCall() {
        if (!this._nextTickCallbacks.length)
            return;
        this._nextTickCallbacks.forEach((cb, idx) => {
            void this._nextTickCallbacks.splice(idx, 1);
            cb();
        });
    }
}
exports.default = StreamDispatcher;
exports.StreamDispatcher = StreamDispatcher;
